<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta name="GENERATOR" content="mkd2html 2.1.5a DL=DISCOUNT">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
  <link rel="stylesheet"
        type="text/css"
        href="../hint.css">
  <title>Most Crafty</title>
</head>
<body>
<h1>Most Crafty</h1>

<p>Gil Dogon<br>
<a href="http://sokoban-gild.com">http://sokoban-gild.com</a></p>

<h2>Judges' comments:</h2>

<h3>To use:</h3>

<pre><code>make

./prog
</code></pre>

<h3>Try:</h3>

<pre><code>./prog

press and hold the Left Arrow key until you turn 90-degrees to the left

when you see a long tunnel, press the function key F2

Use the Up, Down, Left and Right keys to change your path

Press function higher numbered function keys (F3, F4, ...) to go faster

Press F1 to stop

Turn 90-degrees to one side

Press F4 to and drill into some blocks for a bit

Press F1 to stop

Turn 180-degrees to face the way you came

Press F2 and navigate back down the new hole until you reach the long tunnel again

Press F1 to stop

etc.

Press the ESC key
</code></pre>

<h3>Selected Judges Remarks:</h3>

<p>You are in a twisty maze blocks, almost all alike.</p>

<p>Those blocks are generated by  twisty maze of code blocks, almost all different.</p>

<p>Can you find your way around either and understand where you are?</p>

<p>How many function keys does your keyboard have?  Can you generate very high number function keys such as F30 or F31?  :-)</p>

<p><em>Textures? We don&rsquo;t need no stinking textures.</em></p>

<h2>Author&rsquo;s comments:</h2>

<h3>What is it?</h3>

<p>Just run prog with no arguments on an X11-compatible system. The scenery, though pseudo-randomly generated should be strangely familiar, specially to those still in their teen age. You can navigate using the keyboard arrow keys and the function keys. Your speed is a linear function of (n-1) where Fn is the last function key you have pressed, and you always move in the direction you are looking at. Be aware that you are probably some kind of a Creeper as is obvious from looking at the program, hence your movement is destructive to the environment. So after pressing F12 for warp speed, and moving around randomly, you might find yourself in a 3D maze of twisty little passages, from which there is only one Esc(ape) key. Note that in theory if you have a specialty keyboard with 32 function keys you may even press F31 to reach infinite improbability drive speed, though the author had never tested this feature. However a hidden comment in keysymdef.h suggests the existence of a mythical Sun Keyboard with 35 function keys :)</p>

<h3>Full disclosure.</h3>

<p>This entry, tough pretty thoroughly obfuscated, is not entirely original, nor am I Notch. The inspiration for this entry is a demo code written by the Notch himself, which was released with the following  license: &ldquo;you may use the code in here for any purpose in any way you want, at your own risk&rdquo;. That version will henceforth be referred to as the original. Though the original in itself was quite nice and rather dense piece of code, it was not written in C, nor entirely and meticulously obfuscated, a state of things I hopefully rectified.</p>

<h3>Some extra features.</h3>

<p>Basing it on the original which already had a wonderful simple and concise ray casting through a generated voxel world rendering, I added a few tweaks of my own device:</p>

<ul>
<li>Two pass optimized rendering. The program first calculates 1/16 of the output image by ray casting, and then, when possible uses texture interpolation on the voxel faces. It speeds up the rendering by at least a factor of 4 on most scenes, but extra care must be taken when passing rays through the leaves voxels &hellip;</li>
<li>Fixed a small omission in the original. When you looked though a transparent leaves voxel, you did not see the leaves at voxel faces that were far from you. In this version the rendering of those (far face leaves) is correct.</li>
<li>Window rendering size specified in Makefile.</li>
<li>Added the keyboard controls for navigation (and destruction).</li>
</ul>


<h3>Portability issues.</h3>

<p>This entry is rather portable I think on modern platforms. It assumes of course basic X-windows availability. There are several other salient assumptions though:</p>

<ul>
<li>The entry assumes sizeof(int)=4. This seems to cover pretty much everything that supports X-windows so would be broken only on quite ancient machines, embedded processors, or some big iron 64 bit system where sizeof(int)=8.</li>
<li>The entry assumes the default visual has 24 bit depth (RGB). This seems to be the case on most X Servers this days.</li>
<li><p>The entry, does a thing which is an absolute No-No for X-windows program, i.e. assuming it knows some numeric values for keysyms defined in keysymdef.h . I have searched far and wide the lord Google&rsquo;s domain, yet was unable to find a version of the file where those assumptions were broken. This enables the important support of up to 32 function keys keyboards without spilling over the size limit, and allows us to use such fun expression for arrow view control as the following:</p>

<pre><code> *(a&amp;1?&amp;C:&amp;B)-=(.05 -a/2%2*.1)*!(a-1&amp;4092^3920)
</code></pre></li>
</ul>


<h3>Precision issues.</h3>

<p>The entry, on purpose, (see the section about SIMD below) does not use enough bits of precision, so some times the ray will miss the intersection of two voxel faces and push on through. That&rsquo;s why you may notice some noise along close up voxel edges. Fixing this issue would have taken the entry over the size limit regrettably.</p>

<h3>Obfuscations.</h3>

<p>Well, of course you have all the usual suspects, used for extreme compression, and such a nice layout: not very informative identifiers, which are being reused all over the place, some rather gruesome looking expressions, a whole load of magic constants with apparently no rhyme nor reason (including a Lagrange polynomial), and a message from our friendly Cetaceans. However it also includes some clever and not so obvious though instructive techniques, to subtly make the code more magical and efficient, at the same time.</p>

<p>Those techniques are about the use of 64 bit integers in order to do SIMD work, in a portable way without ever using any SSE/AVX or other non-portable compiler inline functions! The irony though, is that when compiling the program on modern X86 architectures indeed SSE/AVX is used for the long longs.
Following is some &ldquo;Spoiler&rdquo; information, So if you want to play tough, stop reading at this point.</p>

<h3>Portable SIMD programming.</h3>

<p>So how is this done? Quite simply by using the whole long long arithmetic&rsquo;s capability. I think the C99 standard assures us that long long has at least 64 bits. Most of those bits are unused in normal programs, however here we use them more wisely. For example, in the inner loop of the program you have the innocent looking expression i+=d. What it does in fact, is a SIMD addition of two vectors, each with three signed fixed point coordinates, advancing our ray in 3D space!
To spell it out, the macro producing such vectors is P, and the assignment q=0x820008202625a0 sets our creeper original position to about (32.5, 32.5019, 2441.406) .</p>

<p>Evidently when doing such arithmetics, care must me taken to avoid overflow from one component to the other, but since our voxel world is a torus of size 64 in each dimension this hardly matters. A subtle issue, is how to deal with signed quantities. In the i+=d expression above i has 3 positive components, but d has arbitrary signed components, as our ray may face in any direction. It seems things should not work, specially as we defined both i and d as unsigned! However notice that the T (and P )macro converts float to  signed long longs. Once sign is extended from a least component into higher bits, it seems at first to be recipe for disaster, however everything works beautifully, and you get precise component results when the final accumulation components in i are positive. This only gets broken a bit when the final accumulation has a least significant negative component. To see this bug in action change the assignment above to q=0x82000820000000, and look towards the negative direction of the main tunnel.</p>

<p>Similar technique is used on the RGB components so their brightness can be adjusted simultaneously by the expression: o=o*b>>8 . Of course some spare bits are needed between the components, so they are spread in the long long and reordered as RBG.</p>

<hr />

<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->

<TABLE><TR>
<TD><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a></TD>
<TD><P>&copy; Copyright 1984-2016, 
<A HREF="/judges.html">Leo Broukhis, Simon Cooper, Landon Curt Noll</A>
- All rights reserved<BR>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</P></TD>
<TD>&nbsp;<!--<a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" height="31" width="88"></a>--></TD>
</TR></TABLE>
</body>
</html>
